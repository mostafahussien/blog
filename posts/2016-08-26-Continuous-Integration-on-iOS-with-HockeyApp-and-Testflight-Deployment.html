<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/blog/_next/static/css/f9263b5821ea6076da2b.css" as="style"/><link rel="stylesheet" href="/blog/_next/static/css/f9263b5821ea6076da2b.css" data-n-g=""/><noscript data-n-css=""></noscript><link rel="preload" href="/blog/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/framework.f8bd46fc02868c500bda.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.7ca2816e457bafd5946e.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/main-830a75c1e9c267725904.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/_app-6248f6fe76d9b87b22d6.js" as="script"/><link rel="preload" href="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-6318cef7c78908ba6bc2.js" as="script"/></head><body><div id="__next"><div>post</div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"title":"Continuous Integration With Deployment to TestFlight and HockeyApp","date":"2020-03-16T05:35:07.322Z","slug":"2016-08-26-Continuous-Integration-on-iOS-with-HockeyApp-and-Testflight-Deployment","author":{"name":"JJ Kasper","picture":"/assets/blog/authors/jj.jpeg"},"content":"\u003cp\u003eWe've recently revised our development process on the iOS team and set up a continuous integration server to make and deploy our builds faster, easier and more consistently. This post should shed some light on what we chose and how we set it up.\u003c/p\u003e\n\u003ch2\u003eThe Requirements\u003c/h2\u003e\n\u003cp\u003eBeing an agency doing client work only, distributing test builds internally and to clients has always been a challenge.\u003c/p\u003e\n\u003cp\u003eFor many years, we have exclusively used \u003ca href=\"http://hockeyapp.com\"\u003eHockeyApp\u003c/a\u003e. As we're juggling an overwhelming amount of client Apple Developer Accounts, it's impractical to gather UDIDs from all of our clients and do new builds every time someone new wants to test an app. This is why we have been using our enterprise account to sign the Hockey builds we make with a \u003ca href=\"https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/AppDistributionGuide/DistributingEnterpriseProgramApps/DistributingEnterpriseProgramApps.html\"\u003ewildcard In-House provisioning profile\u003c/a\u003e.\u003c/p\u003e\n\u003cp\u003eThe drawback of this approach is that all Apple services like push notifications, iCloud or in-app purchases won't work. In order to get those working, you need to create an app identifier with a dedicated provisioning profile; and if you want to release the app on the App Store, this means that you will have to use a different bundle ID than the live app otherwise Apple won't allow you to create the app identifier.\u003c/p\u003e\n\u003cp\u003eWe've chosen to use a combination of \u003ca href=\"http://hockeyapp.com\"\u003eHockeyApp\u003c/a\u003e and \u003ca href=\"https://developer.apple.com/testflight/\"\u003eTestflight\u003c/a\u003e for our beta distribution.\u003c/p\u003e\n\u003cp\u003eTestflight gives us the most accurate representation of how the app will behave when in production, but the delay between uploading and it being available to test can be pretty big. This is why we opted for a model that uploads to both platforms simultaneously. The client only ever tests on Testflight, but HockeyApp is very handy for quickly making a new build available for internal testing by Q/A and Project Managers.\u003c/p\u003e\n\u003cp align=\"center\"\u003e\u003cimg src=\"https://d32wt9uxwfssua.cloudfront.net/tech-blog/uploads/ci_circle.png\"/\u003e\u003c/p\u003e\n\u003cp\u003eThe main requirements or features of a CI server are usually the same for any platform:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eVerifying if the project builds\u003c/li\u003e\n\u003cli\u003eRunning unit tests \u003cem\u003e(future requirement as only our frameworks are tested at the moment)\u003c/em\u003e\u003c/li\u003e\n\u003cli\u003eDeployment\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eOther reasons are very dependent on what kind of work you do either alone or as a company. Making one app for 5 years and deploying tens or hundreds of different apps every day will result in completely different needs.\u003c/p\u003e\n\u003cp\u003eApart from those common requirements, we wanted to setup the CI system so that it keeps our deployment consistent and also save time.\n(Who likes to stare at the screen for 15 minutes while Xcode is archiving?)\u003c/p\u003e\n\u003cp\u003eMost likely, you will run into a discussion about how customizable the system should be. Good thing to keep in mind is, that the more customizable the system will be, the more time-consuming it will be to set up each project. We wanted to be able to use a CI system that would give us quick per project setup with minimum manual work needed and some fair amount of customizability. This, of course results in a longer initial setup time of the actual CI system.\u003c/p\u003e\n\u003ch2\u003eOptions\u003c/h2\u003e\n\u003cp\u003eAn \u003ca href=\"https://en.wikipedia.org/wiki/Comparison_of_continuous_integration_software\"\u003eincreasing number of CI solutions\u003c/a\u003e is becoming available and it feels like there is a new one showing up every day. It makes choosing the right one more difficult and you will usually have to experiment with multiple before you find one that has features you need and actually saves you time.\u003c/p\u003e\n\u003cp\u003eThe current trend seems to be a one-click solution that \u003cem\u003emagically\u003c/em\u003e does everything for you. This usually means very low customizability and proprietary source code. We didn't want to go this way because we like to know what is going on under the hood and how it can be improved or augmented. Also, when \u003cstrong\u003emagic\u003c/strong\u003e breaks, you're in for hours and hours of a total nightmare!\u003c/p\u003e\n\u003ch2\u003eHow did we choose?\u003c/h2\u003e\n\u003cp\u003e\u003cimg src=\"https://d32wt9uxwfssua.cloudfront.net/tech-blog/uploads/jenkins_logo.png\" alt=\"Jenkins\"\u003e\u003c/p\u003e\n\u003cp\u003eSince a few of us had experience with \u003cstrong\u003eJenkins\u003c/strong\u003e it was an obvious first choice and we got our prototype version running in a few days. Jenkins is the king of customizability and features and the industry standard for large projects with complex configurations.\u003c/p\u003e\n\u003cp\u003eWe were quite happy with our setup, only major issues were the initial setup time for each project and overall \u003cem\u003escariness\u003c/em\u003e of the user interface. \u003cstrong\u003eIt was important that everybody could customize their project without feeling like they are launching a nuclear missile.\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"https://d32wt9uxwfssua.cloudfront.net/tech-blog/uploads/gitlab.png\" alt=\"GitLab\"\u003e\u003c/p\u003e\n\u003cp\u003eWe wanted to choose something that would be easy to understand even for our interns or junior developers and since we recently updated our installation of GitLab to the latest version, we've been intrigued to try \u003cstrong\u003eGitLab's Pipelines\u003c/strong\u003e which are specifically meant for continuous integration.\u003c/p\u003e\n\u003cp\u003eRewriting of some of the scripts from Jenkins was needed, but worth the result. We've achieved an extremely easy project setup (just adding one file to the repo) and it's easy to understand for everyone. For more complex projects we allow overriding the build scripts per project, again by just putting them in the repo.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eTL;DR:\u003c/strong\u003e GitLab's Pipelines won for us. Jenkins is scary.\u003c/p\u003e\n\u003ch2\u003eOur Setup\u003c/h2\u003e\n\u003ch3\u003eCommit Message Trigger\u003c/h3\u003e\n\u003cp\u003eWe figured out that the simplest way of triggering a CI build for us will be some magic words in a commit message. We still need to manually increment build and version numbers of our apps, and that's the perfect commit where to make the CI build the project.\u003c/p\u003e\n\u003cp\u003eFirst, we tell the CI where it should deploy the app after building and then the environment the should be set and used when building the app.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e738af0 Fixed stuff [ci testflight staging]\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo maintain consistency we always make a HockeApp build if you select a Testflight build, but in case uploading to Testflight fails for some reason we do support \u003ccode\u003etestflight_only\u003c/code\u003e option, which is especially handy when iTunes Connect API fails as it often does.\u003c/p\u003e\n\u003ch3\u003e.gitlab.yml (GitLab Pipelines Config)\u003c/h3\u003e\n\u003cp\u003eUsed by Gitlab Pipelines to detect if a build/deploy should be done and what exactly should be done. Very similar to how you would configure Travis.\u003c/p\u003e\n\u003cp\u003eWhen run, the YAML file sets project specific environment variables, for example a bundle id or Slack channel name and copies template files, custom ruby scripts and fastlane configuration files into the repository.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-sh\"\u003estages:\n  - build\n\nbuild_project:\n  stage: build\n  script:\n    - export\n      DEVELOPER_DIR=\"/Applications/Xcode.app/Contents/Developer\"\n      FL_SLACK_CHANNEL=\"ios-ci\"\n      SIGH_APP_IDENTIFIER=\"com.nodes.app\"\n      FASTLANE_ITC_TEAM_NAME=\"Nodes ApS\"\n      FASTLANE_ITC_TEAM_ID=\"123456\"\n      HOCKEY_APP_ID=\"123456eabfc1234e456a34565e41e35e41\"\n      MAIN_PLIST_PATH=\"./YourApp/Info.plist\"\n\n    - git clone --depth 1 git@yourgitserver.com:ios/ci-template.git\n    - ruby ./ci-buildtools/nodes-build/nodes-build.rb\n\n  tags:\n    - ios\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eWorth noting is that the copying step only happens if those files don't already exist in the repository, this way we can override actual build steps for complex projects by including modified version of those files in the repository.\u003c/p\u003e\n\u003cp\u003eAs the last step, it runs the main Ruby file to start the build.\u003c/p\u003e\n\u003ch3\u003eRuby Scripts \u0026#x26; Gems\u003c/h3\u003e\n\u003cp\u003eWe are using one custom script and two gems we made to be able to set up and start a build.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"https://github.com/nodes-ios/hockeyver\"\u003ehockeyver\u003c/a\u003e\u003c/strong\u003e is a small gem that fetches last uploaded version and build from HockeyApp given that you provide an API token and app ID. We use this to be able to fail fast and early as all our Testflight builds have a corresponding build on Hockeyapp so we can check if that version already exists before even starting to build.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ hockeyver --app_id YOUR_APP_ID -t YOUR_TOKEN\n26\n\n# Later when used in fastlane\nERROR [2016-08-30 17:12:09.04]: Build failed! Version already exists on hockey.\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003ecarthage_cashier\u003c/strong\u003e is another gem which provides an extra layer of caching on top of a dependency manager we use in most projects - Carthage. It caches all the built products, based on their version and also compiler version, so that we can load from cache when we need it, instead of building all dependencies again. This saves us a lot of time and is useful especially for CI builds, where dependencies rarely change.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ carthage_cashier .\nCopied dependencies from cache: [\"Alamofire\", \"Reachability\"]\nFollowing dependencies not cached, bootstrapping them now: [\"Serializable\", \"Blobfish\"]\n...\nAll dependencies loaded.\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eFastlane\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://fastlane.tools/\"\u003eFastlane\u003c/a\u003e is a newer tool meant for automating various tasks during the development of mobile applications. Think Makefiles on steroids with some nice extra features for iOS. It consists of many different small tools like \u003ccode\u003egym\u003c/code\u003e, \u003ccode\u003esigh\u003c/code\u003e, \u003ccode\u003espaceship\u003c/code\u003e and more that handle all your regular tasks, from (re)signing, deployment to publishing metadata and taking simulator screenshots.\u003c/p\u003e\n\u003cp\u003eAll is configured in one main file, called the \u003ccode\u003efastfile\u003c/code\u003e in \u003cstrong\u003elanes\u003c/strong\u003e, which are just separate steps which you can execute. What we decided to do was to create a template fastfile where all the lanes and commands are preconfigured, so that it wouldn't require any additional setup from the developer on a project. Of course, we made sure it still is possible to provide your own fastfile in projects which would require additional setup.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"language-bash\"\u003e$ bundle exec fastlane test_flight api_env:staging changelog:\"Something fixed.\"\nDEBUG [2016-08-21 16:32:29.23]: Using api_env: staging\nDEBUG [2016-08-21 16:32:29.23]: Using changelog: Something fixed.\n....\nINFO [2016-08-21 16:33:55.01]: Starting with ipa upload to HockeyApp... this could take some time.\n....\nINFO [2016-08-21 16:44:17.10]: fastlane.tools just saved you 12 minutes! ðŸŽ‰\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eSummary\u003c/h2\u003e\n\u003cp\u003eContinuous integration is awesome and you should be using it. After all, it not only makes it easy, fast and consistent to make builds, but also gives you a point on the \u003ca href=\"http://www.joelonsoftware.com/articles/fog0000000043.html\"\u003eJoel Test\u003c/a\u003e!\u003c/p\u003e\n\u003cp align=\"center\"\u003e\u003cimg src=\"https://d32wt9uxwfssua.cloudfront.net/tech-blog/uploads/caveman.jpg\"/\u003e\u003c/p\u003e\n\u003cp\u003eIf you can't afford an in-house computer to set up as a build server or you prefer an all-in-one solution in the cloud, then your best bet would be \u003ca href=\"https://buddybuild.com/\"\u003eBuddyBuild\u003c/a\u003e, which offers a tonne of features and has great support where you can communicate directly with the developers!\u003c/p\u003e\n\u003cp\u003eOn the other hand, if you are producing many apps each with specific requirements you can't always use a simple solution like that. There might also be legal reasons and non-disclosure agreements preventing you from having an external server clone your repository. Or you just prefer to have your own dedicated servers in your own office, which start builds immediately and give you full control.\u003c/p\u003e\n\u003cp\u003eWe are still iterating and improving our current setup, but hopefully, this article has at least made you think about having your own CI up and running.\u003c/p\u003e\n\u003cp\u003e\u003cem\u003eArticle Photo by \u003ca href=\"https://unsplash.com/photos/Ra8x8H7GToE\"\u003eAlexandru Acea\u003c/a\u003e\u003c/em\u003e\u003c/p\u003e\n","ogImage":{"url":"/assets/blog/dynamic-routing/cover.jpg"},"coverImage":"/assets/blog/dynamic-routing/cover.jpg"}},"__N_SSG":true},"page":"/posts/[slug]","query":{"slug":"2016-08-26-Continuous-Integration-on-iOS-with-HockeyApp-and-Testflight-Deployment"},"buildId":"fdDIgXgrkc7rfIP4b_k5S","assetPrefix":"/blog","runtimeConfig":{},"isFallback":false,"gsp":true}</script><script nomodule="" src="/blog/_next/static/chunks/polyfills-4f14e8c8ea1352d3ef0d.js"></script><script src="/blog/_next/static/chunks/webpack-50bee04d1dc61f8adf5b.js" async=""></script><script src="/blog/_next/static/chunks/framework.f8bd46fc02868c500bda.js" async=""></script><script src="/blog/_next/static/chunks/3ef630e34cd10ba68f9d468ac363ff81c534e1e9.7ca2816e457bafd5946e.js" async=""></script><script src="/blog/_next/static/chunks/main-830a75c1e9c267725904.js" async=""></script><script src="/blog/_next/static/chunks/pages/_app-6248f6fe76d9b87b22d6.js" async=""></script><script src="/blog/_next/static/chunks/pages/posts/%5Bslug%5D-6318cef7c78908ba6bc2.js" async=""></script><script src="/blog/_next/static/fdDIgXgrkc7rfIP4b_k5S/_buildManifest.js" async=""></script><script src="/blog/_next/static/fdDIgXgrkc7rfIP4b_k5S/_ssgManifest.js" async=""></script></body></html>